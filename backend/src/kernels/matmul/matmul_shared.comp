#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes : enable

#include "prelude.h"

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer a { readonly  TYPE_P_0 A[]; };
layout(set = 0, binding = 1) buffer b { readonly  TYPE_P_0 B[]; };
layout(set = 0, binding = 2) buffer c {  TYPE_P_0 C[]; };

layout(constant_id = 0) const uint BLOCK_SIZE = 0;
layout(constant_id = 1) const uint localY = 0;
layout(constant_id = 2) const uint M = 0;
layout(constant_id = 3) const uint K = 0;
layout(constant_id = 4) const uint N = 0;

layout(push_constant) uniform PushConstants {
    int partial_wg;
};

//const uint BLOCK_SIZE = 128;//256;

// Block Tile size
const uint BN = 128;//128
const uint BM = 128;//128
// Number of Row or column we read per batch
const uint BK = 8;//8

shared TYPE_P_0 As[BK][BM];
shared TYPE_P_0 Bs[BK][BN];

void main(){
    TYPE_P_0 alpha = TYPE_0(1);
    TYPE_P_0 beta = TYPE_0(1);

    // Thread Tile size
    const uint TN = 4;
    const uint TM = 4;

    const uint nbWaves = BLOCK_SIZE / 32;
    // Wave Tile size 
    const uint WN = 64;//64
    const uint WM = BN * BM / nbWaves / WN;

    // Number of wave on X & Y axis in the Block tile
    uint nbWaveX = BN / WN;
    uint nbWaveY = BM / WM;

    uint waveIndex = gl_LocalInvocationID.x / 32;
    uint waveIdx = waveIndex % nbWaveX;
    uint waveIdy = waveIndex / nbWaveX;
    uint indexInWave = gl_LocalInvocationID.x % 32;

    // A wave is a block of 8x4 of the output matrix
    const uint nbThreadXPerWave = 8;
    const uint nbThreadYPerWave = 4;

    // Thread coordinates in Wave
    uint idxInWave = indexInWave % nbThreadXPerWave;
    uint idyInWave = indexInWave / nbThreadXPerWave;

    const uint nbIterWaveN = WN / (nbThreadXPerWave * TN);
    const uint nbIterWaveM = WM / (nbThreadYPerWave * TM);

    // Wave Sub-tile size
    uint SUBWN = WN / nbIterWaveN;
    uint SUBWM = WM / nbIterWaveM;

    // Thread mapping to read BKxBN block from A
    uint rAIdx = gl_LocalInvocationID.x % BK;
    uint rAIdy = gl_LocalInvocationID.x / BK;
    // Thread mapping to read BNxBK block from B
    uint rBIdx = gl_LocalInvocationID.x % BN;
    uint rBIdy = gl_LocalInvocationID.x / BN;

    uint strideReadB = BLOCK_SIZE / BN;
    uint strideReadA = BLOCK_SIZE / BK;
    uint nbReadsB = BN * BK / BLOCK_SIZE;
    uint nbReadsA = BM * BK / BLOCK_SIZE;

    const uint parital_start = (N / BN) * BN;
    const uint parital_stop = parital_start + (N % BN) - 1;

    TYPE_P_0 A_col[nbIterWaveM * TM];
    TYPE_P_0 B_row[nbIterWaveN * TN];

    [[unroll]]
    for(uint i = 0; i < (nbIterWaveM * TM); i++){
        A_col[i] = TYPE_0(0);
    }
    [[unroll]]
    for(uint i = 0; i < (nbIterWaveN * TN); i++){
        B_row[i] = TYPE_0(0);
    }

    // __shared__ float As[BK][BM];
    // __shared__ float Bs[BK][BN];

    TYPE_P_0 c_regs[TM * nbIterWaveM * TN * nbIterWaveN];
    [[unroll]]
    for(uint i = 0; i < (TM * nbIterWaveM * TN * nbIterWaveN); i++){
        c_regs[i] = TYPE_0(0);
    }

    // Iteration over BK blocks.
    for (uint kId = 0; kId < K; kId += BK)
    {
        // We populate the Shared Memory with Ks row and columns
        [[unroll]]
        for (uint i = 0; i < nbReadsB; i++)
        {
            uint index_x = BN * gl_WorkGroupID.x + rBIdx;
            uint index_y = rBIdy + i * strideReadB + kId;
            Bs[index_y % BK][index_x % BN] = B[N * index_y + index_x];
        }

        [[unroll]]
        for (uint i = 0; i < nbReadsA; i++)
        {
            uint index_x = rAIdx + kId;
            uint index_y = BM * gl_WorkGroupID.y + rAIdy + i * strideReadA;
            As[(index_x % BK)][(index_y % BM)] = A[K * index_y + index_x];
        }

        //__syncthreads();
        barrier();
        memoryBarrierShared();

        [[unroll]]
        for (uint k = 0; k < BK; k += 1)
        {
            // we cache A & B for the entire Wave tile
            [[unroll]]
            for (uint iterWave = 0; iterWave < nbIterWaveN; iterWave++)
            {
                [[unroll]]
                for (uint i = 0; i < TN; i++)
                {
                    uint index = waveIdx * WN +     // waveId
                                iterWave * SUBWN + // wave subtile
                                TN * idxInWave +
                                +i;
                    B_row[iterWave * TN + i] = Bs[k][index];
                }
            }

            [[unroll]]
            for (uint iterWave = 0; iterWave < nbIterWaveM; iterWave++)
            {
                [[unroll]]
                for (uint i = 0; i < TM; i++)
                {
                    uint index = waveIdy * WM +     // waveId
                                iterWave * SUBWM + // wave subtile
                                TM * idyInWave +
                                i;

                    A_col[iterWave * TM + i] = As[k][index];
                }
            }

            // we accumulate to C_regs
            [[unroll]]
            for (uint iterWaveM = 0; iterWaveM < nbIterWaveM; iterWaveM++)
            {
                [[unroll]]
                for (uint iterWaveN = 0; iterWaveN < nbIterWaveN; iterWaveN++)
                {
                    [[unroll]]
                    for (uint yt = 0; yt < TM; yt++)
                    {
                        [[unroll]]
                        for (uint xt = 0; xt < TN; xt++)
                        {
                            uint x = iterWaveN * TN + xt;
                            uint y = iterWaveM * TM + yt;
                            c_regs[y * TN * nbIterWaveN + x] += A_col[y] * B_row[x];
                        }
                    }
                }
            }
        }
        //__syncthreads();
        barrier();
        memoryBarrierShared();
       
    }

    [[unroll]]
    for (uint iterWaveM = 0; iterWaveM < nbIterWaveM; iterWaveM++)
    {
        [[unroll]]
        for (uint iterWaveN = 0; iterWaveN < nbIterWaveN; iterWaveN++)
        {
            uint xOut = gl_WorkGroupID.x * BN + waveIdx * WN + iterWaveN * SUBWN + TN * idxInWave;
            uint yOut = gl_WorkGroupID.y * BM + waveIdy * WM + iterWaveM * SUBWM + TM * idyInWave;
            [[unroll]]
            for (uint yt = 0; yt < TM; yt++)
            {
                [[unroll]]
                for (uint xt = 0; xt < TN; xt++)
                {
                    uint indexC = N * (yOut + yt) + xOut + xt;
                    if(gl_WorkGroupID.x == partial_wg){
                        if((xOut + xt) >= parital_start && (xOut + xt) <= parital_stop){
                            C[indexC] = beta * C[indexC] + alpha * c_regs[TN * nbIterWaveN * (iterWaveM * TM + yt) + (iterWaveN * TN + xt)];
                        }
                    }else{
                        C[indexC] = beta * C[indexC] + alpha * c_regs[TN * nbIterWaveN * (iterWaveM * TM + yt) + (iterWaveN * TN + xt)];
                    }
                    //C[indexC] = TYPE_0(xt);
                    //C[indexC] = TYPE_0(indexC);

                    //C[indexC] = beta * C[indexC] + alpha * c_regs[TN * nbIterWaveN * (iterWaveM * TM + yt) + (iterWaveN * TN + xt)];
                }
            }
        }
    }
}
