#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable

#include "prelude.h"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer a { readonly TYPE_P_0 inData[]; };
layout(set = 0, binding = 1) buffer b { TYPE_P_0 outData[]; };

layout(constant_id = 0) const uint localX = 0;
#define OP_SUM 0
#define OP_MAX 1
#define OP_MIN 2
#define OP_MEAN 3
#define OP_PROD 4
layout(constant_id = 1) const uint op = 0;

layout(push_constant) uniform PushConstants {
	uint start;
	uint stop;
} push;

void main(){
	uint thread_id = uint(gl_GlobalInvocationID.x) + push.start;

	//AXIS_SIZE
	//ADJ_STRIDE
	//ADJ_STRIDE_ADV
	uint indx = thread_id / ADJ_STRIDE_ADV * ADJ_STRIDE + (thread_id % ADJ_STRIDE_ADV);
	
	if(thread_id > push.stop){
        return;
    }

	outData[thread_id] = inData[indx];
	for(uint i = 1; i < AXIS_SIZE; i++){
		switch(op){
        case OP_SUM:
		case OP_MEAN:
            outData[thread_id] += inData[indx + (i * ADJ_STRIDE_ADV)];
            break;
		case OP_MAX:
            outData[thread_id] = max(outData[thread_id], inData[indx + (i * ADJ_STRIDE_ADV)]);
            break;
		case OP_MIN:
            outData[thread_id] = min(outData[thread_id], inData[indx + (i * ADJ_STRIDE_ADV)]);
            break;
		case OP_PROD:
            outData[thread_id] *= inData[indx + (i * ADJ_STRIDE_ADV)];
            break;
		}
	}
	if(op == OP_MEAN){
		outData[thread_id] /= TYPE_0(AXIS_SIZE);
	}
}